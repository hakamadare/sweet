
{{> newCommentFormTemplate}}

<script type="text/javascript">

//this is here bc it's called after a post is made, although it's ALSO called when you click on the "new posts available" notice
function restartInfiniteScroll(timestamp){
  if(!timestamp){
    timestamp = new Date().getTime();
  }
  var postsContainer = $('#postsContainer');
    postsContainer.fadeOut(250,function(){
      postsContainer.html("");
      needPostsOlderThan = timestamp;
      postsContainer.infiniteScroll('loadNextPage');
      postsContainer[0].fadedOut = true;
    });
  }

//NEW POST FORM CODE

$(function(){

  var editor = undefined;
  if(editor = document.getElementById('editor')){
    attachQuill(editor)
  }

  $(".ql-editor").focus(function (e) {
    if(e.target.parentElement.id == "editor"){
      $(".post-controls").css('display', 'flex');
    }
  })

  $("#postContentWarningsButton").click(function () {
    $("#postContentWarningsContainer").removeClass("bounce")
    if ($("#postContentWarningsContainer").is(":hidden")) {
        $("#postContentWarningsContainer").slideDown("fast");
    }
    else if ($("#postContentWarningsContainer").is(":visible") && !$("#postContentWarnings").val()) {
        $("#postContentWarningsContainer").slideUp("fast");
    }
    else {
        $("#postContentWarningsContainer").addClass("bounce")
    }
  })
  $("#postPrivacy-private").change(function () {
    if (this.checked) {
      $("label[for='postPrivacy-private']").html("<i class='fas fa-eye-slash'></i> Private");
      $("label[for='postPrivacy-public']").html("<i class='fas fa-eye'></i>");
    }
  });
  $("#postPrivacy-public").change(function () {
    if (this.checked) {
      $("label[for='postPrivacy-public']").html("<i class='fas fa-eye'></i> Public");
      $("label[for='postPrivacy-private']").html("<i class='fas fa-eye-slash'></i>");
    }
  });
  $("#emojiWindowButton").click(function () {
    $("#emojiWindow").slideToggle("fast");
    $("#editor").find(".ql-editor").focus()
  })
  $("#emojiWindow>.add-emoji").click(function () {
    $("#editor")[0].insertEmojiAtCursor(event.target.innerHTML);
  })
  $('body').on('click', '.reply-to-comment', function() {
    // First, check if the reply form is already open - if it is, just scroll to it
    var commentContainer = $(this).closest('.comment');
    var postID = commentContainer.closest('.post').attr("data-post-id");
    var commentID = commentContainer.attr("data-comment-id");
    var checkFormExists = commentContainer.find('.new-comment-form[data-comment-id="'+commentID+'"]');
    if (checkFormExists.length) {
        if (checkFormExists[0].getBoundingClientRect().bottom > $(window).height()-50){
            $("html, body").animate({ scrollTop: checkFormExists.offset().top-200 }, 200);
        }
        console.log("Form already exists!")
        return;
    }

    // Create new comment form
    var newForm = $(document.getElementById("new-comment-form-template").innerHTML);
    newForm.attr('data-comment-type','child').attr('data-post-id',postID).attr('data-comment-id',commentID);
    newForm.appendTo(commentContainer);
    attachQuill(newForm.find('.editable-text')[0],"Reply to this post with a good reply")
    tribute.attach($(".ql-editor"));
    //Scroll to newly created form
    if (newForm[0].getBoundingClientRect().bottom > $(window).height()-50){
        $("html, body").animate({ scrollTop: newForm.offset().top-200 }, 200);
    }
  })
})

  //IMAGE UPLOADER CODE

  //the main functions are placed outside of the jQuery $(function(){}) document.onready thing because they need to be globally available to the image pasting + dragging and dropping code, not just the event listeners they're attached to directly below.
/*
  //function called right after the file input changes for the post and comment forms or after an image is pasted into an editor (with image(s) contained in imgarray) bc that triggers the change event artificially
  function fileselected(e) {
    if(this.files.length!=0){
      var fileList = this.files;
    }else{
      var fileList = this.pastedFiles;
    }
    let previewContainer = $(this).parent();
    previewContainer.css('display', 'flex'); //this is where we unhide the preview container if this is a comment image. no need to rehide, it's not obtrusive there while empty (at least to me)
    previewContainer = previewContainer[0];

    for (var i = 0; i < fileList.length; i++) {
      //check to make sure it's a supported file type of the correct size
      if (((fileList[i].type === "image/jpeg" || fileList[i].type === "image/png") && fileList[i].size < 10485760) || (fileList[i].type === "image/gif" && fileList[i].size < 5242880)) {

        if ($(previewContainer).children().length == 5) { //if we already have 4 image previews + the file input, which is also a child of the preview container
          bootbox.alert("We only take four images at once atm, sry");
          break;
        }

        var submitbutton = $(this).closest('.contentForm').find('button[type="submit"]');
        submitbutton.html("<i class='fas fa-spinner fa-spin'></i> Uploading").prop('disabled', true);

        //initialize variables for this image uploady thing
        if (!previewContainer.uploadsStarted) {
          previewContainer.uploadsStarted = 0;
          previewContainer.uploadsCompleted = 0;
          previewContainer.uploadsCancelled = 0;
          previewContainer.uploadedImageUrls = [];
          previewContainer.imageUploadRequests = [];
        }

        //add preview windows
        var newimagecont = $(".newimageform").clone();
        newimagecont.find('.image-move')[0].addEventListener('touchstart', touchstartforimagemove, {
          passive: false
        });
        newimagecont.attr('class', 'newimagecont').attr('uploadnumber', previewContainer.uploadsStarted).appendTo(previewContainer);

        //create filereader that will obtain us the preview
        var fr = new FileReader();
        fr.uploadNumber = previewContainer.uploadsStarted; //lets us find the preview window to give this image to when done
        fr.previewContainer = previewContainer;
        fr.onload = function (e) {
          let bgRecipient = $(this.previewContainer).find('.newimagecont[uploadnumber="' + this.uploadNumber + '"]');
          if (bgRecipient) { //our preview window might have already been eliminated by a cancel operation
            bgRecipient.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
          }
        }
        fr.fileType = fileList[i].type;
        fr.readAsDataURL(fileList[i]);

        //make the image-uploading ajax request
        var fd = new FormData();
        fd.append('image', fileList[i]);

        let imageUploadReq = $.ajax({
          xhr: function(){
            var uploader = new XMLHttpRequest();
            var uploadNumber = previewContainer.uploadsStarted;
            uploader.upload.addEventListener("progress", function(e){
              var thisImagesWindow = $(previewContainer).find('.newimagecont[uploadnumber="' + uploadNumber + '"]');
              var percentage = Math.round(e.loaded / e.total * 100);
              thisImagesWindow.find('progress').attr('value',percentage);
              thisImagesWindow.find("#percentage").html(percentage==100 ? percentage+'%!!!' : percentage+'%')
            });
            return uploader;
          },
          url: '/api/image/v2',
          type: 'POST',
          data: fd,
          processData: false,
          contentType: false
        });
        imageUploadReq.uploadNumber = previewContainer.uploadsStarted;
        imageUploadReq.previewContainer = previewContainer;
        imageUploadReq.fail(function(jqXHR, textStatus, errorThrown){
          var thisImagesWindow = $(previewContainer).find('.newimagecont[uploadnumber="' + jqXHR.uploadNumber + '"]');
          thisImagesWindow.find('progress').attr('value',0);
          thisImagesWindow.find("#percentage").html("Upload error :( Hit the X and try again?")
        })
        imageUploadReq.done(function (data, textstatus, jqXHR) {
          //find the corresponding preview window
          var thisImagesWindow = $(jqXHR.previewContainer).find('.newimagecont[uploadnumber="' + jqXHR.uploadNumber + '"]');

          var serverResponse = JSON.parse(data);
          //check for filesize error. shouldn't ever happen bc of the check around this whole function, but we need server-side checking still anyway, so...
          if (serverResponse.error) {
            if(serverResponse.error == "filesize"){
              bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
            }else if(serverResponse.error == "filetype"){
              bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
            }
            jqXHR.previewContainer.uploadsCancelled++;
            if (jqXHR.previewContainer.uploadsStarted - jqXHR.previewContainer.uploadsCancelled == jqXHR.previewContainer.uploadsCompleted) {
              let submitbutton = thisImagesWindow.closest(".contentForm").find('button[type="submit"]');
              submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
            }
            thisImagesWindow.remove();
          } else {

            if(serverResponse.thumbnail){
              thisImagesWindow.find('.image-preview').css('background-image',"url(" + serverResponse.thumbnail + ")"); //we want the server-created thumbnail bc it will be exif-rotated and transparency-removed as seen fit
            }
            thisImagesWindow.find('.fader').remove();

            jqXHR.previewContainer.uploadedImageUrls.push(serverResponse.url); //will be at position given by uploadsCompleted
            thisImagesWindow.attr('urlpos', jqXHR.previewContainer.uploadsCompleted++); //so we can figure out which url to remove when that window's delete button is hit
            if (jqXHR.previewContainer.uploadsStarted - jqXHR.previewContainer.uploadsCancelled == jqXHR.previewContainer.uploadsCompleted) {
              let submitbutton = thisImagesWindow.closest(".contentForm").find('button[type="submit"]');
              submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
            }
          }
        });
        previewContainer.imageUploadRequests.push(imageUploadReq); //will be positioned at the preview window's uploadnumber
        ++previewContainer.uploadsStarted;
      } else {
        if (!(fileList[i].type === "image/jpeg" || fileList[i].type === "image/gif" || fileList[i].type === "image/png")) {
          bootbox.alert("You appear to have sent us a file of unsupported type! Atm we only take gifs, jpgs, and pngs");
        } else {
          bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
        }
      }
    }
    $(previewContainer).children('input').val(''); //we need to reset this so that file selection consistently registers as a 'change' event
  }
*/
$(function(){
  $("body").on('click', '#postImageButton', function (e) {
    let ourFileInputGuy = $(this).closest('.contentForm, .new-comment-form').children('.file-input');
    //attach the function to the file input object events when necessary. can't do them all at once 'cause they're not loaded all at once
    if (!ourFileInputGuy[0].changeEventAttached) {
      ourFileInputGuy.change(function(e){
        var n = $(this).parent().find('.ql-container')[0];
        for(var i=0; i < this.files.length; i++){
          if(n.imagesAdded > 3){
            bootbox.alert("we only take 4 images at a time right now, sorry");
            break;
          }else{
            n.addImage(this.files[i]);
          }
        }
      }); //basically, i think this should call an addImage function on the relevant ql-container instead, which inserts the image preview into the quill... area
      ourFileInputGuy[0].changeEventAttached = true;
    }
    ourFileInputGuy.click();
    //todo: disable post sumbit button, give it the uploading text and spinner
  })

$("body").on('click', '#postLinkButton', function(e) {
    var urlEntry = $(this).closest('.contentForm, .new-comment-form').children('.link-form-cont');
    if(urlEntry.is(':hidden')){
      urlEntry.slideDown();
    }else{
      urlEntry.slideUp();
    }
})

$("body").on('click', ".link-add", function(e){
  var input = $(this).siblings('input')
  var url = input.val();
  input.val('');
  var subject = $(this).closest('.contentForm, .new-comment-form').find('.ql-container')[0];
  if(subject.linkPreviewsAdded < 10000){ //this could probably be changed to something lower
    subject.addLinkPreview(url);
  }else{
    bootbox.alert("we only take 10000 link previews per post, sorry");
  }
})

$("body").on('keyup',"#linkPreviewUrlEntry", function(e){
  if(e.keyCode==13){ //activate on pressing enter
    $(this).siblings('.link-add').click();
  }
})


  //function for removing an image from a post or comment
  $("body").on('click', '.image-clearnotused', function (e) { //not currently in use,
    let thisPreviewWindow = $(this).parent().parent();
    let previewContainer = thisPreviewWindow.parent()[0];
    let reqid = thisPreviewWindow.attr('uploadnumber');
    let thisReq = previewContainer.imageUploadRequests[reqid];
    if (thisReq.readyState != 4) { //if the upload is still in progress
      thisReq.abort();
      ++previewContainer.uploadsCancelled;
      if (previewContainer.uploadsStarted - previewContainer.uploadsCancelled == previewContainer.uploadsCompleted) {
        var submitbutton = $(this).closest(".contentForm").find('button[type="submit"]');
        submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
      }
    } else {
      let url = previewContainer.uploadedImageUrls[thisPreviewWindow.attr('urlpos')];
      $.post("/cleartempimage", {
        imageURL: url
      });
      previewContainer.uploadedImageUrls[thisPreviewWindow.attr('urlpos')] = ""; //we can't just remove the url without throwing off the numbering for all following ones
    }
    thisPreviewWindow.remove();
  })

  var haveWeSentPost = false;
  //function for very specifically submitting a post, not a comment
  $("#postSubmit").click(function (e) {
    if (haveWeSentPost) {
      return;
    }
    e.preventDefault();
    let editor = $('#editor');
    let postContent = editor.find(".ql-editor").html();
    let pc = $(this).closest('.post-controls').siblings('#image-preview-holder')[0]; //bit sketchy! oh well
    //only do anything if there are no pending uploads and there is some text or image(s) to post
    if ((!pc.uploadsStarted || pc.uploadsCompleted == pc.uploadsStarted - pc.uploadsCancelled) && ($(pc).find('.newimagecont').length != 0 || editor[0].hasContent())) {
      let sortedurls = []; //putting urls in preview-window order, instead of the order in which they were recieved from the server
      let imagedescs = [];
      for (let i = 0; i < $(pc).find('.newimagecont').length; i++) {
        let imageWindow = $($(pc).find('.newimagecont')[i]); // i feel like there's a cleaner way to do this than $($())
        sortedurls.push(pc.uploadedImageUrls[imageWindow.attr('urlpos')]);
        imagedescs.push(imageWindow.find('#postImageDescription').val());
      }
      $(this).attr('disabled');
      $.ajax({
        url: '/createpost',
        type: 'POST',
        data: {
          communityId: $('#postForm').attr("communityId"),
          postPrivacy: ($('#postPrivacy-public').is(':checked') ? 'public' : 'private'),
          postContent: postContent,
          postContentWarnings: $('#postContentWarnings').val(),
          postImageDescription: JSON.stringify(imagedescs),
          postImageURL: JSON.stringify(sortedurls),
        }
      }).done(function (postTimestamp) { //actually this should be a string set to the 1 millisecond later than the new post's timestamp.
        $('#postContentWarnings').val("");
        $("#postContentWarningsContainer").slideUp("fast");
        editor.find(".ql-editor").html("");
        $(pc).children('.newimagecont').remove();
        haveWeSentPost = false;
        restartInfiniteScroll(postTimestamp) //we'll requests posts older than that specific timestamp, so the new post should always be on top, with any even newer posts not shown.
      });
      haveWeSentPost = true;
    } else {
      bootbox.alert("This post appears to be... empty");
    }
  });

  //function for sumbitting a comment and then placing the new comment on the page
  $('body').on('click', '.create-comment', function() {
    let commentButton = $(this);
    let commentForm = commentButton.closest('.new-comment-form');
    let commentType = commentForm.attr('data-comment-type');
    let postID = commentForm.attr('data-post-id');
    let commentID = commentForm.attr('data-comment-id');
    let commentContainer = commentForm.find(".ql-container");
    let commentEditor = commentForm.find('.ql-editor');
    let commentContent = commentEditor.html();
    if (commentType == "primary") {
        commentsContainer = commentButton.closest('.comments').find('.comments-container');
    }
    else if (commentType == "child") {
        commentsContainer = commentButton.closest('.comments-container').find('.comment[data-comment-id='+commentID+']').find('.replies')[0];
    }
    let emojiWindow = commentForm.find('.replyEmojiWindow');

    let pc = commentForm.find('#image-preview-holder')[0];

    var sortedurls = []; //will contain urls in preview-window order, instead of the order in which they were recieved from the server
    var imagedescs = [];

    if(pc.uploadsCompleted){
      if(pc.uploadsCompleted != pc.uploadsStarted-pc.uploadsCancelled){
        bootbox.alert("You have image uploads in progress.");
        return;
      }else{
        for(let i=0; i < $(pc).find('.newimagecont').length; i++){
          let imageWindow = $($(pc).find('.newimagecont')[i]); // i feel like there probably exists a cleaner way to do this than $($())?
          sortedurls.push(pc.uploadedImageUrls[imageWindow.attr('urlpos')]);
          imagedescs.push(imageWindow.find('#postImageDescription').val());
        }
      }
    }

    if (commentContainer[0].hasContent() || sortedurls.length > 0) { // Filter out empty comments
      commentButton.prop('disabled', true);
      $.post("/createcomment/"+postID+"/"+commentID,
      { commentContent: commentContent,
        imageUrls: JSON.stringify(sortedurls),
        imageDescs: JSON.stringify(imagedescs)
      },
      function(data) {
        if (data!='nope'){
          commentEditor.html('');
          var appendedComment = $(data.comment).hide().appendTo(commentsContainer).fadeIn();
          //add the lightbox listener to the newly appended comment images
          var commentimages = appendedComment.find('.post-images a');
          if (commentimages.length > 0) {
            var $images = commentimages;
            var $imagesGrouped = $images.filter('[data-group]');
            var $imagesAlone = $images.not($imagesGrouped);
            var params = {
              // your params
            };

            // Handle standalone images
            $imagesAlone.each(function (index, element) {
              $(element).simpleLightbox(params);
            });

            // Handle grouped imags
            if ($imagesGrouped.length > 0) {
              // Select all groups
              var groupNames = $imagesGrouped.map(function () {
                return $(this).data('group');
              }).get();
              groupNames = $.unique(groupNames);

              // Apply on each group
              $.each(groupNames, function (key, value) {
                $imagesGrouped.filter(function () {
                    return $(this).data('group') == value;
                  })
                  .simpleLightbox(params);
              });
            }
          }

          let counterToChange = commentButton.closest(".post").find(".show-comments").find('.comments-number')[0];
          if(counterToChange.textContent === ""){
            counterToChange.innerHTML = "1";
          } else {
            let newCommentCount = parseInt(counterToChange.textContent)+1;
            counterToChange.innerHTML = counterToChange.innerHTML.replace((newCommentCount-1), newCommentCount);
          }
          // Reset (or DESTROY) comment form
          if (commentType == "primary") {
              commentButton.prop('disabled', false);
              emojiWindow.hide();
              $(pc).children('.newimagecont').remove(); //removes all image preview windows
          }
          else if (commentType == "child") {
              commentForm.remove();
          }
          pc.uploadsStarted = 0;
          pc.uploadsCompleted = 0;
          pc.uploadsCancelled = 0;
          pc.uploadedImageUrls = [];
          pc.imageUploadRequests = [];
        } else {
          let html = '<article class="comment"><div class="alert alert-danger">There has been a problem posting your comment. Sorry! Please copy the comment text, refresh the page, and try again.</div></article>'
          $(html).hide().appendTo(commentsContainer).fadeIn();
          // commentButton.prop('disabled', false); // Probably don't disable the reply button if an error occurs because god knows what else has happened to the form
        }
      });
    }
  })
})


//IMAGE DRAG-AND-DROP ORDERING STUFF

  //PART 1: THE FUNCTIONS THAT DO THE WORK

/*
$(function(){
  $('body').on('mousedown', '.image-move', function (e) {
    e.preventDefault();
    var selectedImage = $(this).parent().parent();
    //only do something if there's at least one other element to switch positions with
    if (selectedImage.parent().children().length <= 1) {
      return;
    }

    //turms selectedImage into a spacer element. floatyImageCont is going to contain the image now instead.
    var floatyImageCont = prepareImageForMoving(selectedImage);

    $(document).mousemove(function (e) {
      moveimagecont(e.originalEvent.movementY, floatyImageCont, selectedImage);
    });

    $(document).on('mouseup', function (e) {
      movementEnded();
      $(document).off('mousemove');
    });
  });
});

  var touchinprogress = false;

  //this is attached to the preview window's arrow thing when the preview window is created input change event listener
  function touchstartforimagemove(e) {

    if (e.cancelable) {
      e.preventDefault();
    }

    if (touchinprogress) {
      return; //don't want to try to move two images at once, everything would probably need to be rewritten for that
    }
    touchinprogress = true;

    var selectedImage = $(this).parent().parent();
    //only do something if there's at least one other image container to switch positions with
    if (selectedImage.parent().children().length <= 2) { //2 = one image container and the file input element.
      return;
    }

    var floatyImageCont = prepareImageForMoving(selectedImage);

    var previousY = e.changedTouches[0].screenY;

    //function to be passed to the touchmove handler and then later removed from it
    function touchmoveevent(event) {
      //this should always be true, if it's not preventDefault raises an error instead of preventing page scrolling and we have Problems
      if (event.cancelable) {
        event.preventDefault();
      }

      moveimagecont(-1 * (previousY - event.changedTouches[0].screenY), floatyImageCont, selectedImage);
      previousY = event.changedTouches[0].screenY;
    }

    //for some reason jQuery Did Not Want to work with these touch events. Possibly they would like us to be using jQuery Mobile. But, this is pretty simple, we don't need it.
    this.addEventListener("touchmove", touchmoveevent, {
      passive: false
    });

    this.addEventListener('touchend', function (e) {
      touchinprogress = false;
      this.removeEventListener('touchmove', touchmoveevent);
      movementEnded();
    });

    this.addEventListener('touchcancel', function (e) {
      touchinprogress = false;
      this.removeEventListener('touchmove', touchmoveevent);
      movementEnded();
    });
  }*/
  
</script>
