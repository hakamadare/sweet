<script type="text/custom-template" id="new-post-link-preview-contents">
    <img class="link-preview-image" src="/images/spinner-stolen.gif" />
    <div class="link-preview-text-container" style="width:100%;">
        <span class="link-preview-title">...loading...</span>
        <span class="link-preview-description">...loading...</span>
        <span class="link-preview-domain">...loading...</span>
    </div>
    <div class="image-preview-controls">
        <a href="javascript:void(0)" class="image-control image-clear" title="Clear"><i class="fas fa-times"></i></a>
        <a href="javascript:void(0)" class="image-control image-move" title="Move" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></a>
    </div>
</script>

<script type="text/custom-template" id="new-post-image-preview-contents">
    <div class="image-preview">
        <div class="fader" style="color:white;background-color:#00000088;display:flex;align-items:center;justify-content:center;height:100%;width:100%;flex-direction:column;">
            <div id="percentage" style="padding:5px 5px;">0%</div><progress max="100" value="0"></progress>
        </div>
    </div>
    <textarea class="form-control mb-3" name="postImageDescription" id="postImageDescription" placeholder="Describe this image for people using screen readers."></textarea>
    <div class="image-preview-controls">
        <a href="javascript:void(0)" class="image-control image-clear" title="Clear image"><i class="fas fa-times"></i></a>
        <a href="javascript:void(0)" class="image-control image-move" title="Move image" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></a>
    </div>
</script>

<script>

    //within-editor embeds utility functions:

    function updateSubmitButtonState(postForm){
        var button = postForm.find('.create-comment, #postSubmit');
        if(postForm.find('.still-loading').length == 0){
            var button = postForm.find('.create-comment, #postSubmit');
            button.attr('disabled',false);
            if(button.hasClass('create-comment')){
                button.html("Reply");
            }else if(button.attr('id')=="postSubmit"){
                button.html('Send <i class="fas fa-chevron-right"></i>');
            }
        }else{
            button.attr('disabled',true);
            button.html("<i class='fas fa-spinner fa-spin'></i> Uploading");
        }
    }

    //attached to the x of the embeds above and below when a new one is created after a rearrangement
    function clearEmbed(e) {
        var m = $(this).parent().parent();
        if (m[0].request && m[0].request.readyState != 4) {
            m[0].request.abort();
        }
        if (m.hasClass('newimagecont')) {
            m.parent(0).linkPreviewAdded--;
        } else if (m.hasClass('link-preview-container')) {
            m.parent()[0].linkPreviewsAdded--;
        }
        m.remove();
        updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
    }

    var newEmbedId = 0; //this increments every time an embed is added in an editor anywhere and forms part of their ids so they can all be uniquely identified
    //in callbacks that affect embeds, they should be selected by their ids that are formed from this instead of using the existing node variable, bc the re-arranger may have removed the original element

    //register embed types!
    let BlockEmbed = Quill.import('blots/block/embed');
    class LinkPreview extends BlockEmbed {
        static create(url) {
            //taken from https://stackoverflow.com/questions/19377262/regex-for-youtube-url
            var youtubeUrlFindingRegex = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/
            //taken from https://github.com/regexhq/vimeo-regex/blob/master/index.js
            var vimeoUrlFindingRegex = /^(http|https)?:\/\/(www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|)(\d+)(?:|\/\?)$/
            var isVideo = (youtubeUrlFindingRegex.test(url) || vimeoUrlFindingRegex.test(url));
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('data-url', url);
            node.setAttribute('contenteditable', false);
            node.innerHTML = $("#new-post-link-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass('still-loading');
            node.request = $.post("/api/newpostform/linkpreviewdata", { url: url }, function(data, status, jqXHR) {
                var m = $("#embed" + id);
                if (!m) { return; }
                m.removeClass('still-loading');
                if (data == "invalid url i guess") {
                    bootbox.alert("Sorry, we couldn't connnect to that url (" + url + ") to obtain a preview :(")
                    if ($(".onthemove")) {
                        movementEnded()
                    }
                    m.parent()[0].linkPreviewsAdded--;
                    m.remove();
                } else {
                    var linkInfo = JSON.parse(data);
                    m.find(".link-preview-image").attr('src', linkInfo.image)
                    m.find('.link-preview-title').html(linkInfo.title);
                    m.find('.link-preview-description').html(linkInfo.description);
                    m.find('.link-preview-domain').html(linkInfo.domain + (isVideo ? ' (will open as embed)' : ''));
                }
                updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
            })
            node.request.fail(function(){
                var m = $("#embed" + id);
                if (!m) { return; }
                m.removeClass('still-loading');
                bootbox.alert("Sorry, we couldn't connect to that url (" + url + ") to obtain a preview :(")
                if ($(".onthemove")) {
                    movementEnded();
                }
                m.parent()[0].linkPreviewsAdded--;
                m.remove();
                updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
            })

            n.find('.image-clear').click(clearEmbed);
            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        static value(node) {
            return node.getAttribute('data-url');
        }
    }

    LinkPreview.blotName = 'LinkPreview';
    LinkPreview.tagName = 'a';
    LinkPreview.className = 'link-preview-container';
    Quill.register(LinkPreview);

    var files = {}; //each file object is stored in this object under the container's id so that if a user deletes an image embed and then undoes that action, quill can find the file in here and reconstitute the embed from it.
    class PostImage extends BlockEmbed {
        static create(file) {
            if(file.type != "image/jpeg" && file.type != "image/png" && file.type != "image/gif"){
                bootbox.alert("Sorry, but this appears to be an unsupported file type! We only take JPG, PNG, and GIF images at the moment");
                return null;
            }else if (!(((file.type === "image/jpeg" || file.type === "image/png") && file.size < 10485760) || (file.type === "image/gif" && file.size < 5242880))) {
                bootbox.alert("Sorry, but this file appears to be too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                return null;
            }
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            files[node.getAttribute('id')] = file;
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('contenteditable', false);
            node.setAttribute('image-url', 'loading...')
            node.innerHTML = $("#new-post-image-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass("still-loading");
            //create filereader that will obtain us the preview
            var fr = new FileReader();
            fr.onload = function(e) {
                var m = $("#embed" + id)
                if (m) { //our preview window might have already been eliminated by a cancel operation
                    m.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
                }
            }
            fr.fileType = file.type;
            fr.readAsDataURL(file);

            //make the image-uploading ajax request
            var fd = new FormData();
            fd.append('image', file);

            node.request = $.ajax({
                xhr: function() {
                    var uploader = new XMLHttpRequest();
                    uploader.upload.addEventListener("progress", function(e) {
                        var percentage = Math.round(e.loaded / e.total * 100);
                        var m = $("#embed" + id)
                        m.find('progress').attr('value', percentage);
                        m.find("#percentage").html(percentage == 100 ? percentage + '%!!!' : percentage + '%')
                    });
                    return uploader;
                },
                url: '/api/image/v2',
                type: 'POST',
                data: fd,
                processData: false,
                contentType: false,
                error: function(jqxhr, status, error) {
                    var m = $("#embed" + id)
                    m.find('progress').attr('value', 0);
                    m.find("#percentage").html("Upload error :( Hit the X and try again?");
                    console.log(status);
                    console.log(error);
                    $.post("/admin/reporterror", { errorstring: error });
                    updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));                    
                },
                success: function(data, status, jqXHR) {
                    var m = $("#embed" + id)
                    m.removeClass("still-loading");
                    var serverResponse = JSON.parse(data);
                    //check for filesize error. shouldn't ever happen bc of the check around this whole function, but we need server-side checking still anyway, so...
                    if (serverResponse.error) {
                        if (serverResponse.error == "filesize") {
                            bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                        } else if (serverResponse.error == "filetype") {
                            bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
                        }
                        if ($(".onthemove")) {
                            movementEnded()
                        }
                        m.parent()[0].imagesAdded--;
                        m.remove(); //test this maybe
                    } else {
                        if (serverResponse.thumbnail) {
                            m.find('.image-preview').css('background-image', "url(" + serverResponse.thumbnail + ")"); //we want the server-created thumbnail bc it will be exif-rotated and transparency-removed as seen fit
                        }
                        m.find('.fader').remove();
                        m.attr('image-url', serverResponse.url);
                        updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                    }
                }
            });

            n.find('.image-clear').click(function(e) {
                var m = $("#embed" + id);
                if (m[0].request && m[0].request.readyState != 4) {
                    m[0].request.abort();
                } else if (m.attr('image-url') != 'loading...') {
                    $.post("/cleartempimage", { imageURL: m.attr('image-url') });
                }
                m.parent()[0].imagesAdded--;
                m.remove();
            });

            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        static value(node) {
            return files[node.getAttribute('id')];
        }

        static formats(node) {
            return { description: $(node).find('#postImageDescription').val(), imageURL: node.getAttribute('image-url') };
        }
    }
    PostImage.blotName = 'PostImage';
    PostImage.tagName = 'div';
    PostImage.className = 'newimagecont';
    Quill.register(PostImage);

    function attachQuill(element, placeholder) {
        var quill = new Quill(element, {
            modules: {
                toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
                keyboard: {
                    bindings: {
                        //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                        blqtBksp: {
                            key: 'backspace',
                            collapsed: true,
                            format: ['blockquote'],
                            offset: 0,
                            handler: function(range, context) {
                                this.quill.format('blockquote', false);
                            }
                        },
                        //also, if the user hits backspace with the cursor on a newline after an embed, delete the newline (instead of the embed before it)
                        embedBksp: {
                            key: 'backspace',
                            collapsed: true,
                            offset: 0,
                            handler: function(range, context){
                                if(this.quill.getText(range.index,1)=="\n"){
                                    var before = this.quill.getContents(range.index-1,1);
                                    if(before.ops.length && before.ops[0].insert && (before.ops[0].insert.LinkPreview || before.ops[0].insert.PostImage)){
                                        this.quill.deleteText(range.index,1);
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                }
            },
            placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
            theme: 'bubble'
        });
        //remove pasted formatting that we don't support
        quill.clipboard.addMatcher("img", function(node, delta) {
            return { ops: [] };
        });
        quill.clipboard.addMatcher("*", function(node, delta) {
            for (var i = 0; i < delta.ops.length; i++) {
                for (const key in delta.ops[i].attributes) {
                    if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                        delete delta.ops[i].attributes[key];
                    }
                }
            }
            return delta;
        })
        //save the most recent cursor position when the editor loses focus
        quill.on('selection-change', function(range, oldRange, source) {
            if (!range) {
                element.lastCursorPos = oldRange.index;
            }
        })
        //prevent there from ever being embeds with no new lines to type text on
        quill.on('text-change',function(range,oldRange,source){
            if(quill.getText()==""){
                quill.insertText(quill.getLength(),"\n");
            }
        })
        element.insertEmojiAtCursor = function(emojiString) {
            var range = undefined;
            if (range = quill.getSelection()) { //if editor has focus
                if (range.length > 0) { //if there is some text selected
                    quill.deleteText(range.index, range.length);
                }
                quill.insertText(range.index, emojiString)
            } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
                quill.insertText(element.lastCursorPos, emojiString)
            } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
                quill.insertText(0, emojiString)
                quill.focus()
                quill.setSelection(emojiString.length, 0)
            }
        }
        element.hasContent = function() {
            //if there is some text the first will be true; if there are > 0 embeds, the second will be true
            return (quill.getText().trim().length > 0 || quill.getLength() > quill.getText().length);
        }
        element.getContents = function() {
            var c = quill.getContents();
            if(c.ops && c.ops[0].insert && typeof c.ops[0].insert == "string"){
                c.ops[0].insert = c.ops[0].insert.replace(/^\s+/, ''); //remove starting whitespace
            }
            if(c.ops && c.ops[c.ops.length-1] && typeof c.ops[c.ops.length-1].insert == "string"){
                c.ops[c.ops.length-1].insert = c.ops[c.ops.length-1].insert.replace(/\s+$/, ''); //remove ending whitespace
            }
            return c;
        }
        //addImage and addLinkPreview functions! the other functions for rearranging those things within the text can go outside of this function, below
        //embeds are added at the bottom of the editor unless the cursor is on a blank line with text somewhere below it.
        element.addLinkPreview = function(url) {
            var sel = quill.getSelection(true);
            var range = sel.index;
            if(sel.length==0 && quill.getText(range,1)=="\n" && quill.getText(range+1,1)!=""){
                quill.deleteText(range,1);
                var addEmbedAt = range;
            }else{
                var addEmbedAt = quill.getLength();
            }
            quill.insertEmbed(addEmbedAt, 'LinkPreview', url, Quill.sources.USER);
            element.linkPreviewsAdded++;
            updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
        }

        element.addImage = function(file) {
            var sel = quill.getSelection(true);
            var range = sel.index;
            if(sel.length==0 && quill.getText(range,1)=="\n" && quill.getText(range+1,1)!=""){
                quill.deleteText(range,1);
                var addEmbedAt = range;
            }else{
                var addEmbedAt = quill.getLength();
            }
            quill.insertEmbed(addEmbedAt, 'PostImage', file, Quill.sources.USER);
            element.imagesAdded++;
            updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
        }
        element.imagesAdded = 0;
        element.linkPreviewsAdded = 0;
        //listen for and use pasted image data
        element.onpaste = function(e) {
            var imagesAdded = false;
            // event.originalEvent.clipboard for newer chrome versions
            var items = (event.clipboardData || event.originalEvent.clipboardData).items;
            for (var i = 0; i < items.length; i++) {
                if (element.imagesAdded > 3) {
                    bootbox.alert("sorry, we only take 4 images at once atm");
                    break;
                } else {
                    if (items[i].type.indexOf("image") === 0) {
                        element.addImage(items[i].getAsFile());
                        imagesAdded = true;
                    }
                }
            }
            if (imagesAdded) {
                e.preventDefault();
                return false; //no idea if this actually does anything but just in case
            }
        }
        //listen for and use dragged-and-dropped images
        element.ondrop = function(ev) {
            ev.preventDefault();
            $(".post-controls").css('display', 'flex'); //just in case the user hasn't previously clicked in the text area
            if (ev.dataTransfer.items) {
                for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                    if (element.imagesAdded > 3) {
                        bootbox.alert("sorry, we only take 4 images at once atm");
                        break;
                    } else if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                        element.addImage(ev.dataTransfer.items[i].getAsFile());
                    }
                }
            } else {
                for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                    if (element.imagesAdded > 3) {
                        bootbox.alert("sorry, we only take 4 images at once atm");
                        break;
                    } else if (ev.dataTransfer.files[i].type.indexOf("image") === 0) {
                        element.addImage(ev.dataTransfer.files[i]);
                    }
                }
            }
            removeBodyFader();
        }
    }

    
    //incremented and decremented and reset by drag event listeners to keep track of whether the dragged thing is still in our window or not
    var dragcounter = 0;
    var faded = false;

    function removeBodyFader(e) {
        e.preventDefault();
        $("#bodyFader").fadeOut(100, function() {
            $("#bodyFader").remove();
            dragcounter = 0;
            faded = false;
        });
    }

    //this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
    //it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
    needPostsOlderThan = new Date().getTime();

    $(function() {
        //this stuff is all here bc it's relevant to the drag-and-drop handling code for the quill editor above
        //this activates the fader that dims non-drag-and-drop elements (has a z-index 1 lower than the editor areas)
        document.body.ondragover = function(e) {
            e.preventDefault();
            var dt = e.dataTransfer;
            //so it won't react if just some text or image from the page is being dragged around
            if (dt.types && (dt.types.indexOf ? dt.types.indexOf('Files') != -1 : dt.types.contains('Files'))) {
                if (!faded) {
                    $('body').append('<div id="bodyFader"></div>');
                    $("#bodyFader").fadeIn(100);
                    var faded = true;
                }
            }
        }

        //neutralize a drag-and-drop if it doesn't hit a specific text entry area - assume they just missed
        document.body.ondragend = removeBodyFader;
        document.body.ondrop = removeBodyFader
        //some byzantine logic required to detect when the dragged thing leaves our window entirely:
        window.ondragenter = function(e) {
            e.preventDefault();
            dragcounter++;
        }
        window.ondragleave = function(e) {
            dragcounter--;
            if (dragcounter < 1) {
                removeBodyFader(e);
            }
        }
    })

    //scripts for rearranging the embeds within the text editor

    //these event listener functions are initially attached to the embeds' movement handles,when they're created, above

    function mousedownOnHandle(e) {
        e.preventDefault();
        var selectedImage = $(this).parent().parent();

        //turms selectedImage into a selectedImage element. floatyImageCont is going to contain the image now instead.
        var floatyImageCont = prepareImageForMoving(selectedImage);

        $(document).mousemove(function(e) {
            e.preventDefault();
            moveimagecont(e.originalEvent.movementY, floatyImageCont, selectedImage);
            return false;
        });

        $(document).on('mouseup', function(e) {
            movementEnded();
            $(document).off('mousemove');
        });
    }

    var touchinprogress = false;

    function touchStartOnHandle(e) {

        if (e.cancelable) {
            e.preventDefault();
        }

        if (touchinprogress) {
            return; //don't want to try to move two images at once, everything would probably need to be rewritten for that
        }
        touchinprogress = true;

        var selectedImage = $(this).parent().parent();

        var floatyImageCont = prepareImageForMoving(selectedImage);

        var previousY = e.changedTouches[0].screenY;

        //function to be passed to the touchmove handler and then later removed from it
        function touchmoveevent(event) {
            //this should always be true, if it's not preventDefault raises an error instead of preventing page scrolling and we have Problems
            if (event.cancelable) {
                event.preventDefault();
            }

            moveimagecont(-1 * (previousY - event.changedTouches[0].screenY), floatyImageCont, selectedImage);
            previousY = event.changedTouches[0].screenY;
        }

        //for some reason jQuery Did Not Want to work with these touch events. Possibly they would like us to be using jQuery Mobile. But, this is pretty simple, we don't need it.
        this.addEventListener("touchmove", touchmoveevent, { passive: false });

        this.addEventListener('touchend', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            movementEnded();
        });

        this.addEventListener('touchcancel', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            movementEnded();
        });
    }

    //called as soon as movement is initiated:
    //this functions creates and returns a new, floaty version of the element you pass in and turns the original into an empty "spacer"
    function prepareImageForMoving(selectedImage) {
        var spacer = selectedImage;

        var imagecont = spacer.clone(false);
        imagecont.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });
        imagecont.find('.image-move').on('mousedown', mousedownOnHandle);
        imagecont.find('.image-clear').click(clearEmbed);

        spacer.addClass("imagecontspacer");
        spacer.attr('id', '');

        var imagecontpos = spacer.offset();

        imagecont.css("width", spacer.outerWidth(true) + "px");
        imagecont.css("left", imagecontpos.left + "px");
        imagecont.css("top", imagecontpos.top + "px");

        spacer.closest('.ql-container').append(imagecont);

        //these can be put in the css file under .onthemove if that's preferred. I guess I would rather have them here
        imagecont.css("position", "fixed");
        imagecont.css("z-index", 2147483647); // over 9000
        imagecont.css("background-color", "white");

        imagecont.addClass("onthemove");

        spacer.css("border", "dashed")
        spacer.empty();

        return imagecont;
    }

    //this function is called when the user moves either their mouse or finger to reposition the embed.
    function moveimagecont(deltaY, imagecont, spacer) {
        //move the floaty element:
        var imageconttop = imagecont.offset().top;
        var imageconth = imagecont.outerHeight(true);
        //new y pos is the old y pos + the mouse's delta-y unless that's less than the parent's top bound or more than the parent's bottom bound - the height of the element
        var newYPos = Math.min(Math.max(imageconttop + deltaY, spacer.parent().offset().top), spacer.parent().offset().top + (spacer.parent().outerHeight() - spacer.outerHeight())); //beauty
        imagecont.css("top", newYPos + "px");

        //move the spacer (maybe):

        if (deltaY > 0) { //moving down
            var elementBelow = spacer.next();
            while (elementBelow.length && elementBelow.next().length && (imageconttop + imageconth) > (elementBelow.offset().top + elementBelow.outerHeight(true))) {
                elementBelow = elementBelow.next();
            }
            if (elementBelow.length) {
                var ebt = elementBelow.offset().top;
                var line = Math.max(ebt + (0.5 * elementBelow.outerHeight(true)), ebt + elementBelow.outerHeight(true) - 70);
                if ((imageconttop + imageconth) > line) {
                    spacer.insertAfter(elementBelow);
                }
            }
        } else if (deltaY < 0) { //moving up
            var elementAbove = spacer.prev();
            while (elementAbove.length && elementAbove.prev().length && imageconttop < elementAbove.offset().top) {
                elementAbove = elementAbove.prev();
            }
            if (elementAbove.length) {
                var line = Math.min(elementAbove.offset().top + (0.5 * elementAbove.outerHeight(true)), elementAbove.offset().top + 70);
                if (imageconttop < line) {
                    spacer.insertBefore(elementAbove);
                }
            }
        }
    }

    //this function is called when the user lifts their finger from their screen or mouse button and the image can find its spot.
    function movementEnded() {
        $('.imagecontspacer').after($('.onthemove'));
        $('.onthemove').css("position", "").css("border", "").css('width', '').css('left', '').css('top', '').css('height', '').css("z-index", 10); //seems like a good number
        $('.onthemove').removeClass("onthemove");
        var spacer = $('.imagecontspacer');
        if (!spacer.next().length && !(spacer.prev().length && spacer.prev().text().trim() == "")) {
            spacer.after("<p></p>")
        }
        spacer.remove();
    }
</script>