<script type="text/custom-template" id="new-post-link-preview-contents">
    <div style="display:flex;justify-content:center;position:relative;">
        <img class="link-preview-image" src="/images/spinner-stolen.gif" />
    </div>
    <div class="link-preview-text-container" style="width:100%;">
        <span class="link-preview-title">...loading...</span>
        <span class="link-preview-description">...loading...</span>
        <span class="link-preview-domain">...loading...</span>
    </div>
<div class="image-preview-controls">
    <a href="javascript:void(0)" class="image-control image-clear" title="Clear"><i class="fas fa-times"></i></a>
    <a href="javascript:void(0)" class="image-control image-move" title="Move" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></a>
  </div>
</script>

<script type="text/custom-template" id="new-post-image-preview-contents">
  <div class="image-preview"><div class="fader" style="color:white;background-color:#00000088;display:flex;align-items:center;justify-content:center;height:100%;width:100%;flex-direction:column;"><div id="percentage" style="padding:5px 5px;">0%</div><progress max="100" value="0"></progress></div></div>
  <textarea class="form-control mb-3" name="postImageDescription" id="postImageDescription" placeholder="Describe this image for people using screen readers." {{#if sessionFlash.errorImageDescription }}value="{{sessionFlash.errorImageDescription}}" {{/if}}></textarea>
  <div class="image-preview-controls">
    <a href="javascript:void(0)" class="image-control image-clear" title="Clear image"><i class="fas fa-times"></i></a>
    <a href="javascript:void(0)" class="image-control image-move" title="Move image" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></a>
  </div>
</script>

<script>
    //register embed types!
    let BlockEmbed = Quill.import('blots/block/embed');
    class LinkPreview extends BlockEmbed {
        static create(url) {
            //taken from https://stackoverflow.com/questions/19377262/regex-for-youtube-url
            var youtubeUrlFindingRegex = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/
            //taken from https://github.com/regexhq/vimeo-regex/blob/master/index.js
            var vimeoUrlFindingRegex = /^(http|https)?:\/\/(www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|)(\d+)(?:|\/\?)$/
            var isVideo = (youtubeUrlFindingRegex.test(url) || vimeoUrlFindingRegex.test(url));
            let node = super.create();
            node.setAttribute('data-url', url);
            node.setAttribute('contenteditable',false);
            node.innerHTML = $("#new-post-link-preview-contents")[0].innerHTML;
            var n = $(node);
            node.request = $.post("/api/newpostform/linkpreviewdata",{url:url},function(data,status,jqXHR){
                if(data=="invalid url i guess"){
                    bootbox.alert("Sorry, we couldn't connnect to that url ("+url+") to obtain a preview :(")
                    n.remove();
                    node.linkPreviewsAdded--;
                }else{
                    var linkInfo = JSON.parse(data);
                    n.find(".link-preview-image").attr('src',linkInfo.image)
                    n.find('.link-preview-title').html(linkInfo.title);
                    n.find('.link-preview-description').html(linkInfo.description);
                    n.find('.link-preview-domain').html(linkInfo.domain + (isVideo ? ' (will open as embed)' : ''));
                }
            })
            n.find('.image-clear').click(function(e){
                if(node.request && node.request.readyState!=4){
                    node.request.abort();
                }
                n.remove();
                node.linkPreviewsAdded--;
            })
            return node;
        }

        static value(node) {
            return node.getAttribute('data-url');
        }
    }

    LinkPreview.blotName = 'LinkPreview';
    LinkPreview.tagName = 'a';
    LinkPreview.className = 'link-preview-container';
    Quill.register(LinkPreview);
    class PostImage extends BlockEmbed {
        static create(file) {
            let node = super.create();
            node.setAttribute('contenteditable', false);
            node.setAttribute('image-url', 'loading...')
            node.innerHTML = $("#new-post-image-preview-contents")[0].innerHTML;
            var n = $(node);

            //create filereader that will obtain us the preview
            var fr = new FileReader();
            fr.onload = function(e) {
                if (n) { //our preview window might have already been eliminated by a cancel operation
                    n.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
                }
            }
            fr.fileType = file.type;
            fr.readAsDataURL(file);

            //make the image-uploading ajax request
            var fd = new FormData();
            fd.append('image', file);

            node.request = $.ajax({
                xhr: function() {
                    var uploader = new XMLHttpRequest();
                    uploader.upload.addEventListener("progress", function(e) {
                        var percentage = Math.round(e.loaded / e.total * 100);
                        n.find('progress').attr('value', percentage);
                        n.find("#percentage").html(percentage == 100 ? percentage + '%!!!' : percentage + '%')
                    });
                    return uploader;
                },
                url: '/api/image/v2',
                type: 'POST',
                data: fd,
                processData: false,
                contentType: false,
                error: function(jqxhr,status,error) {
                    n.find('progress').attr('value', 0);
                    n.find("#percentage").html("Upload error :( Hit the X and try again?");
                    console.log(status);
                    console.log(error);
                },
                success: function(data, status, jqXHR) {
                    var serverResponse = JSON.parse(data);
                    //check for filesize error. shouldn't ever happen bc of the check around this whole function, but we need server-side checking still anyway, so...
                    if (serverResponse.error) {
                        if (serverResponse.error == "filesize") {
                            bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                        } else if (serverResponse.error == "filetype") {
                            bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
                        }
                        n.remove();
                        node.imagesAdded--;
                    } else {
                        if (serverResponse.thumbnail) {
                            n.find('.image-preview').css('background-image', "url(" + serverResponse.thumbnail + ")"); //we want the server-created thumbnail bc it will be exif-rotated and transparency-removed as seen fit
                        }
                        n.find('.fader').remove();
                        n.attr('image-url', serverResponse.url);
                    }
                }
            });

            n.find('.image-clear').click(function(e) {
                if (node.request && node.request.readyState != 4) {
                    node.request.abort();
                }else if(n.attr('image-url') != 'loading...'){
                    $.post("/cleartempimage", {
                        imageURL: n.attr('image-url')
                    });
                }
                n.remove();
                node.imagesAdded--;
            });
            return node;
        }

        static value(node) {
            return node.getAttribute('image-url');
        }

        static formats(node) {
            return { description: $(node).find('#postImageDescription').val() };
        }
    }
    PostImage.blotName = 'PostImage';
    PostImage.tagName = 'div';
    PostImage.className = 'newimagecont';
    Quill.register(PostImage);

    function attachQuill(element, placeholder) {
    var quill = new Quill(element, {
        modules: {
            toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
            keyboard: {
                bindings: {
                    //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                    blqtBksp: {
                        key: 'backspace',
                        collapsed: true,
                        format: ['blockquote'],
                        offset: 0,
                        handler: function(range, context) {
                            this.quill.format('blockquote', false);
                        }
                    }
                }
            }
        },
        placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
        theme: 'bubble'
    });
    //remove pasted formatting that we don't support
    quill.clipboard.addMatcher("img", function(node, delta) {
        return { ops: [] };
    });
    quill.clipboard.addMatcher("*", function(node, delta) {
        for (var i = 0; i < delta.ops.length; i++) {
            for (const key in delta.ops[i].attributes) {
                if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                    delete delta.ops[i].attributes[key];
                }
            }
        }
        return delta;
    })
    //save the most recent cursor position when the editor loses focus
    quill.on('selection-change', function(range, oldRange, source) {
        if (!range) {
            element.lastCursorPos = oldRange.index;
        }
    })
    element.insertEmojiAtCursor = function(emojiString) {
        var range = undefined;
        if (range = quill.getSelection()) { //if editor has focus
            if (range.length > 0) { //if there is some text selected
                quill.deleteText(range.index, range.length);
            }
            quill.insertText(range.index, emojiString)
        } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
            quill.insertText(element.lastCursorPos, emojiString)
        } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
            quill.insertText(0, emojiString)
            quill.focus()
            quill.setSelection(emojiString.length, 0)
        }
    }
    element.hasContent = function() {
        return $(element).text().trim().length !== 0;
    }
    //listen for and use pasted image data
    element.onpaste = function(e) {
        var imagesAdded = false;
        // event.originalEvent.clipboard for newer chrome versions
        var items = (event.clipboardData || event.originalEvent.clipboardData).items;
        for (var i = 0; i < items.length; i++) {
            if(element.imagesAdded > 3){
                bootbox.alert("sorry, we only take 4 images at once atm");
                break;
            }else{
                if (items[i].type.indexOf("image") === 0) {
                    element.addImage(items[i].getAsFile());
                    imagesAdded = true;
                }
            }
        }
        if(imagesAdded){
            e.preventDefault();
            return false; //no idea if this actually does anything but just in case
        }
    }
    //listen for and use dragged-and-dropped images
    element.ondrop = function(ev) {
        ev.preventDefault();
        $(".post-controls").css('display', 'flex'); //just in case the user hasn't previously clicked in the text area
        if (ev.dataTransfer.items) {
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                if(element.imagesAdded > 3){
                    bootbox.alert("sorry, we only take 4 images at once atm");
                    break;
                }else if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                    element.addImage(ev.dataTransfer.items[i].getAsFile());
                }
            }
        } else {
            for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                if(element.imagesAdded > 3){
                    bootbox.alert("sorry, we only take 4 images at once atm");
                    break;
                }else if (ev.dataTransfer.files[i].type.indexOf("image") === 0) {
                    element.addImage(ev.dataTransfer.files[i]);
                }
            }
        }
        $("#bodyFader").fadeOut(100,function(){
            $("#bodyFader").remove();
        });

        dragcounter = 0;
    }
    //addImage and addLinkPreview functions! the other functions for rearranging those things within the text can go outside of this function, below

    element.addLinkPreview = function(url){
        quill.insertEmbed(quill.getSelection(true).index, 'LinkPreview', url, Quill.sources.USER);
        element.linkPreviewsAdded++;
    }

    element.addImage = function(file){
        quill.insertEmbed(quill.getSelection(true).index, 'PostImage', file, Quill.sources.USER);
        element.imagesAdded++;
    }

    element.imagesAdded = 0;
    element.linkPreviewsAdded = 0;
}
//incremented and decremented and reset by drag event listeners to keep track of whether the dragged thing is still in our window or not
var dragcounter = 0;

//this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
//it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
needPostsOlderThan = new Date().getTime();

$(function() {
    //this stuff is all here bc it's relevant to the drag-and-drop handling code for the quill editor above
    //this activates the fader that dims non-drag-and-drop elements (has a z-index 1 lower than the editor areas)
    document.body.ondragover = function(e){
        e.preventDefault();
        var dt = e.dataTransfer;
        //so it won't react if just some text or image from the page is being dragged around
        if (dt.types && (dt.types.indexOf ? dt.types.indexOf('Files') != -1 : dt.types.contains('Files'))){
            if(!document.getElementById("bodyFader")){
                $('body').append('<div id="bodyFader"></div>');
                $("#bodyFader").fadeIn(100);
            }
        }
    }
    function removeBodyFader(e){
        e.preventDefault();
        $("#bodyFader").fadeOut(100,function(){
            $("#bodyFader").remove();
            dragcounter = 0;
        });
    }
    //neutralize a drag-and-drop if it doesn't hit a specific text entry area - assume they just missed
    document.body.ondragend = removeBodyFader;
    document.body.ondrop = removeBodyFader
    //some byzantine logic required to detect when the dragged thing leaves our window entirely:
    window.ondragenter = function(e){
        e.preventDefault();
        dragcounter++;
    }
    window.ondragleave = function(e){
        dragcounter--;
        if(dragcounter<1){
            removeBodyFader(e);
        }
    }
})
</script>