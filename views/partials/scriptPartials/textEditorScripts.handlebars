<script type="text/custom-template" id="new-post-link-preview-contents">
    <img class="link-preview-image" src="/images/spinner-stolen.gif" />
    <div class="link-preview-text-container" style="width:100%;">
        <span class="link-preview-title">...loading...</span>
        <span class="link-preview-description">...loading...</span>
        <span class="link-preview-domain">...loading...</span>
    </div>
    <div class="image-preview-controls">
        <div class="image-control image-clear" title="Clear"><i class="fas fa-times"></i></div>
        <div class="image-control image-move" title="Move" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></div>
    </div>
</script>

<script type="text/custom-template" id="new-post-image-preview-contents">
    <div class="image-preview">
        <div class="fader" style="position: absolute;top: 0;display: flex;flex-direction:column;color:white;background-color:#00000088;display:flex;align-items:center;justify-content:center;height:100%;width:100%;flex-scrollDirection:column;">
            <div id="percentage" style="padding:5px 5px;">0%</div><progress max="100" value="0"></progress>
        </div>
    </div>
    <textarea class="form-control mb-3" name="postImageDescription" id="postImageDescription" placeholder="Describe this image for people using screen readers."></textarea>
    <div class="image-preview-controls">
        <div class="image-control image-clear" title="Clear image"><i class="fas fa-times"></i></div>
        <div class="image-control image-move" title="Move image" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></div>
    </div>
</script>

<script>
    //within-editor embeds utility functions:

    function updateSubmitButtonState(postForm) {
        var button = postForm.find('.create-comment, #postSubmit');
        if (postForm.find('.still-loading').length == 0) {
            var button = postForm.find('.create-comment, #postSubmit');
            button.attr('disabled', false);
            if (button.hasClass('create-comment')) {
                button.html("Reply");
            } else if (button.attr('id') == "postSubmit") {
                button.html('Send <i class="fas fa-chevron-right"></i>');
            }
        } else {
            button.attr('disabled', true);
            button.html("<i class='fas fa-spinner fa-spin'></i> Uploading");
        }
    }

    //attached to the x of the embeds above and below when a new one is created after a rearrangement
    function clearEmbed(e) {
        var m = $(this).parent().parent();
        if (m[0].request && m[0].request.readyState != 4) {
            m[0].request.abort();
        }
        var postform = m.closest('.new-comment-form, .contentForm');
        m.remove();
        updateSubmitButtonState(postform);
    }

    var newEmbedId = 0; //this increments every time an embed is added in an editor anywhere and forms part of their ids so they can all be uniquely identified
    //in callbacks that affect embeds, they should be selected by their ids that are formed from this instead of using the existing node variable, bc the re-arranger may have removed the original element

    //register embed types!
    let BlockEmbed = Quill.import('blots/block/embed');
    class LinkPreview extends BlockEmbed {
        static create(url) {
            //taken from https://stackoverflow.com/questions/19377262/regex-for-youtube-url
            var youtubeUrlFindingRegex = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/
            //taken from https://github.com/regexhq/vimeo-regex/blob/master/index.js
            var vimeoUrlFindingRegex = /^(http|https)?:\/\/(www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|)(\d+)(?:|\/\?)$/
            var isVideo = (youtubeUrlFindingRegex.test(url) || vimeoUrlFindingRegex.test(url));
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('data-url', url);
            node.setAttribute('contenteditable', false);
            node.innerHTML = $("#new-post-link-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass('still-loading');
            node.request = $.post("/api/newpostform/linkpreviewdata", { url: url }, function(data, status, jqXHR) {
                var m = $("#embed" + id);
                if (!m.length) { return; }
                m.removeClass('still-loading');
                if (data == "invalid url i guess") {
                    bootbox.alert("Sorry, we couldn't connnect to that url (" + url + ") to obtain a preview :(")
                    m.find('.image-clear').click();
                } else {
                    var linkInfo = JSON.parse(data);
                    m.find(".link-preview-image").attr('src', linkInfo.image)
                    m.find('.link-preview-title').html(linkInfo.title);
                    m.find('.link-preview-description').html(linkInfo.description);
                    m.find('.link-preview-domain').html(linkInfo.domain + (isVideo ? ' (will open as embed)' : ''));
                    updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                }
            })
            node.request.fail(function(jqXHR, textStatus, error) {
                var m = $("#embed" + id);
                if (!m.length) { return; }
                m.removeClass('still-loading');
                bootbox.alert("Sorry, we couldn't connect to that url (" + url + ") to obtain a preview :(");
                m.find('.image-clear').click();
                if (error != "abort") {
                    $.post("/admin/reporterror", { errorstring: "error creating link preview for url " + url + ":\n" + error });
                }
            })

            n.find('.image-clear').click(clearEmbed);
            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        static value(node) {
            return node.getAttribute('data-url');
        }

        static formats(node) {
            var n = $(node);
            return { title: n.find('.link-preview-title').html(), description: n.find('.link-preview-description').html(), domain: n.find('.link-preview-domain').html().replace(' (will open as embed)', ''), image: n.find('.link-preview-image').attr('src') }
        }
    }

    LinkPreview.blotName = 'LinkPreview';
    LinkPreview.tagName = 'a';
    LinkPreview.className = 'link-preview-container';
    Quill.register(LinkPreview);

    var files = {}; //each file object is stored in this object under the container's id so that if a user deletes an image embed and then undoes that action, quill can find the file in here and reconstitute the embed from it.
    class PostImage extends BlockEmbed {
        static create(file) {
            if (file.type != "image/jpeg" && file.type != "image/png" && file.type != "image/gif") {
                bootbox.alert("Sorry, but this appears to be an unsupported file type! We only take JPG, PNG, and GIF images at the moment");
                return null;
            } else if (!(((file.type === "image/jpeg" || file.type === "image/png") && file.size < 10485760) || (file.type === "image/gif" && file.size < 5242880))) {
                bootbox.alert("Sorry, but this file appears to be too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                return null;
            }
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            files[node.getAttribute('id')] = file;
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('contenteditable', false);
            node.setAttribute('image-url', 'loading...')
            node.innerHTML = $("#new-post-image-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass("still-loading");
            //create filereader that will obtain us the preview
            var fr = new FileReader();
            fr.onload = function(e) {
                var m = $("#embed" + id)
                if (m) { //our preview window might have already been eliminated by a cancel operation
                    m.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
                }
            }
            fr.fileType = file.type;
            fr.readAsDataURL(file);

            //make the image-uploading ajax request
            var fd = new FormData();
            fd.append('image', file);

            node.request = $.ajax({
                xhr: function() {
                    var uploader = new XMLHttpRequest();
                    uploader.upload.addEventListener("progress", function(e) {
                        var percentage = Math.round(e.loaded / e.total * 100);
                        var m = $("#embed" + id)
                        m.find('progress').attr('value', percentage);
                        m.find("#percentage").html(percentage == 100 ? percentage + '%!!!' : percentage + '%')
                    });
                    return uploader;
                },
                url: '/api/image/v2',
                type: 'POST',
                data: fd,
                processData: false,
                contentType: false,
                error: function(jqxhr, status, error) {
                    var m = $("#embed" + id)
                    m.find('progress').attr('value', 0);
                    m.find("#percentage").html("Upload error :( Hit the X and try again?");
                    console.log("image upload error: " + error);
                    m.removeClass('still-loading');
                    updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                    if (error != "abort") {
                        $.post("/admin/reporterror", { errorstring: "error uploading image:\n" + error });
                    }
                },
                success: function(data, status, jqXHR) {
                    var m = $("#embed" + id)
                    m.removeClass("still-loading");
                    var serverResponse = JSON.parse(data);
                    //check for file errors. shouldn't ever happen bc of the check at the beginning of this function, but we need server-side checking still anyway, so...
                    if (serverResponse.error) {
                        if (serverResponse.error == "filesize") {
                            bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                        } else if (serverResponse.error == "filetype") {
                            bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
                        }
                        endMovement()
                        m.find('.image-clear').click();
                    } else {
                        if (serverResponse.thumbnail) {
                            m.find('.image-preview').css('background-image', "url(" + serverResponse.thumbnail + ")"); //we want the server-created thumbnail bc it will be exif-rotated and transparency-removed as seen fit
                        }
                        m.find('.fader').remove();
                        m.attr('image-url', serverResponse.url);
                        updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                    }
                }
            });

            n.find('.image-clear').click(clearEmbed);

            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        static value(node) {
            return files[node.getAttribute('id')];
        }

        static formats(node) {
            return { description: $(node).find('#postImageDescription').val(), imageURL: node.getAttribute('image-url') };
        }
    }
    PostImage.blotName = 'PostImage';
    PostImage.tagName = 'div';
    PostImage.className = 'newimagecont';
    Quill.register(PostImage);

    function attachQuill(element, placeholder, embedsForbidden) {
        var quill = new Quill(element, {
            modules: {
                toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
                keyboard: {
                    bindings: {
                        //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                        blqtBksp: {
                            key: 'backspace',
                            collapsed: true,
                            format: ['blockquote'],
                            offset: 0,
                            handler: function(range, context) {
                                this.quill.format('blockquote', false);
                            }
                        },
                        //also, if the user hits backspace with the cursor on a newline after an embed, delete the newline (instead of the embed before it)
                        embedBksp: {
                            key: 'backspace',
                            collapsed: true,
                            offset: 0,
                            handler: function(range, context) {
                                if (this.quill.getText(range.index, 1) == "\n") {
                                    var before = this.quill.getContents(range.index - 1, 1);
                                    if (before.ops.length && before.ops[0].insert && (before.ops[0].insert.LinkPreview || before.ops[0].insert.PostImage)) {
                                        this.quill.deleteText(range.index, 1);
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                }
            },
            placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
            theme: 'bubble'
        });
        //remove pasted formatting that we don't support
        quill.clipboard.addMatcher("img", function(node, delta) {
            return { ops: [] };
        });
        quill.clipboard.addMatcher("*", function(node, delta) {
            for (var i = 0; i < delta.ops.length; i++) {
                for (const key in delta.ops[i].attributes) {
                    if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                        delete delta.ops[i].attributes[key];
                    }
                }
            }
            return delta;
        })
        $(element).children('.ql-editor')[0].oncopy = function(e) {
            e.preventDefault();
            //sets the clipboard to just have text contents instead of trying to copy embeds which is erratic (link previews can theoretically always be copied but images malfunction bc we might not have access to that file anymore)
            if ((!e.target.className.includes("link-preview")) && e.target.id != "postImageDescription") {
                //if the user is copying from the editor directly we just need to set the clipboard contents to the selected plain text
                var s = quill.getSelection();
                e.clipboardData.setData('text/plain', quill.getText(s.index, s.length));
            } else {
                //if the user is copying from link preview text or the image description that they just wrote we need to set the clipboard to the selected plain text from that element.
                var text = "";
                //this is for copying out of the image description textarea:
                var activeEl = document.activeElement;
                var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
                if (
                    (activeElTagName == "textarea") || (activeElTagName == "input" &&
                        /^(?:text|search|password|tel|url)$/i.test(activeEl.type)) &&
                    (typeof activeEl.selectionStart == "number")
                ) {
                    text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
                    //and this is for copying out of anything else:
                } else if (window.getSelection) {
                    text = window.getSelection().toString();
                }
                e.clipboardData.setData('text/plain', text);
            }
            return false;
        }
        //save the most recent cursor position when the editor loses focus for emoji picker placement
        quill.on('selection-change', function(range, oldRange, source) {
            if (!range) {
                element.lastCursorPos = oldRange.index;
            }
        })
        element.insertEmojiAtCursor = function(emojiString) {
            var range = undefined;
            if (range = quill.getSelection()) { //if editor has focus
                if (range.length > 0) { //if there is some text selected
                    quill.deleteText(range.index, range.length);
                }
                quill.insertText(range.index, emojiString)
            } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
                quill.insertText(element.lastCursorPos, emojiString)
            } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
                quill.insertText(0, emojiString)
                quill.focus()
                quill.setSelection(emojiString.length, 0)
            }
        }
        element.hasContent = function() {
            //if there is some text the first will be true; if there are > 0 embeds, the second will be true
            return (quill.getText().trim().length > 0 || quill.getLength() > quill.getText().length);
        }
        if (!embedsForbidden) {
            //when embeds are forbidden, the html contents of the .ql-editor element will be used instead of the below
            element.getContents = function() {
                quill.updateContents();
                var c = quill.getContents();
                if (c.ops && c.ops[0].insert && typeof c.ops[0].insert == "string") {
                    c.ops[0].insert = c.ops[0].insert.replace(/^\s+/, ''); //remove starting whitespace
                }
                if (c.ops && c.ops[c.ops.length - 1] && typeof c.ops[c.ops.length - 1].insert == "string") {
                    c.ops[c.ops.length - 1].insert = c.ops[c.ops.length - 1].insert.replace(/\s+$/, ''); //remove ending whitespace
                }
                return c;
            }
            //prevent there from ever being embeds at the end of the content with no new lines after to type text on
            quill.on('text-change', function(range, oldRange, source) {
                if (quill.getText() === "") {
                    quill.insertText(quill.getLength(), "\n");
                }
            })
            //addImage and addLinkPreview functions! the other functions for rearranging those things within the text can go outside of this function, below
            //embeds are added at the bottom of the editor unless the cursor is on a blank line with text somewhere below it.
            element.addLinkPreview = function(url) {
                var sel = quill.getSelection(true);
                var range = sel.index;
                if (sel.length == 0 && quill.getText(range, 1) == "\n" && quill.getText(range + 1, 1) != "") {
                    quill.deleteText(range, 1);
                    var addEmbedAt = range;
                } else {
                    var addEmbedAt = quill.getLength();
                }
                quill.insertEmbed(addEmbedAt, 'LinkPreview', url, Quill.sources.USER);
                updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
            }

            element.addImage = function(file) {
                var sel = quill.getSelection(true);
                var range = sel.index;
                if (sel.length == 0 && quill.getText(range, 1) == "\n" && quill.getText(range + 1, 1) != "") {
                    quill.deleteText(range, 1);
                    var addEmbedAt = range;
                } else {
                    var addEmbedAt = quill.getLength();
                }
                quill.insertEmbed(addEmbedAt, 'PostImage', file, Quill.sources.USER);
                updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
            }
            element.imagesAdded = function() {
                return $(element).children('.ql-editor').children('.newimagecont').length;
            }
            element.linkPreviewsAdded = function() {
                return $(element).children('.ql-editor').children('.link-preview-container').length;
            }
            //create a blank line when someone clicks on the space below an embed if it's the last thing in the editor
            element.onclick = function(e){
                var lastThingInEditor = $(element).children('.ql-editor').children().last();
                if(lastThingInEditor.hasClass('link-preview-container') || lastThingInEditor.hasClass('newimagecont')){
                    if(e.clientY > getTop(lastThingInEditor)+lastThingInEditor.outerHeight(false)){
                        quill.insertText(quill.getLength(),'\n');
                        quill.setSelection(quill.getLength(),0);
                    }
                }
            }
            //listen for and use pasted image data
            element.onpaste = function(e) {
                // event.originalEvent.clipboard for newer chrome versions
                var items = (event.clipboardData || event.originalEvent.clipboardData).items;
                for (var i = 0; i < items.length; i++) {
                    if (element.imagesAdded() > 3) {
                        bootbox.alert("sorry, we only take 4 images at once atm");
                        break;
                    } else {
                        if (items[i].type.indexOf("image") === 0) {
                            element.addImage(items[i].getAsFile());
                            e.preventDefault();
                        }
                    }
                }
            }
            //listen for and use dragged-and-dropped images
            element.ondrop = function(ev) {
                ev.preventDefault();
                $(".post-controls").css('display', 'flex'); //just in case the user hasn't previously clicked in the text area
                if (ev.dataTransfer.items) {
                    for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                        if (element.imagesAdded() > 3) {
                            bootbox.alert("sorry, we only take 4 images at once atm");
                            break;
                        } else if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                            element.addImage(ev.dataTransfer.items[i].getAsFile());
                        }
                    }
                } else {
                    for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                        if (element.imagesAdded() > 3) {
                            bootbox.alert("sorry, we only take 4 images at once atm");
                            break;
                        } else if (ev.dataTransfer.files[i].type.indexOf("image") === 0) {
                            element.addImage(ev.dataTransfer.files[i]);
                        }
                    }
                }
                removeBodyFader(ev);
            }
            if (!dragFaderActivated) {
                $(function() {
                    //this stuff is all here bc it's relevant to the drag-and-drop handling code for the quill editor above
                    //this activates the fader that dims non-drag-and-drop elements (has a z-index 1 lower than the editor areas)
                    document.body.ondragover = function(e) {
                        e.preventDefault();
                        var dt = e.dataTransfer;
                        //so it won't react if just some text or image from the page is being dragged around
                        if (dt.types && (dt.types.indexOf ? dt.types.indexOf('Files') != -1 : dt.types.contains('Files'))) {
                            if (!faded) {
                                $('body').append('<div id="bodyFader"></div>');
                                $("#bodyFader").fadeIn(100);
                                faded = true;
                            }
                        }
                    }

                    //neutralize a drag-and-drop if it doesn't hit a specific text entry area - assume they just missed
                    document.body.ondragend = removeBodyFader;
                    document.body.ondrop = removeBodyFader
                    //some byzantine logic required to detect when the dragged thing leaves our window entirely:
                    window.ondragenter = function(e) {
                        e.preventDefault();
                        dragcounter++;
                    }
                    window.ondragleave = function(e) {
                        dragcounter--;
                        if (dragcounter < 1) {
                            removeBodyFader(e);
                        }
                    }
                })
                dragFaderActivated = true;
            }
        }
    }


    //incremented and decremented and reset by drag event listeners to keep track of whether the dragged thing is still in our window or not
    var dragcounter = 0;
    var faded = false;
    dragFaderActivated = false;

    function removeBodyFader(e) {
        e.preventDefault();
        $("#bodyFader").fadeOut(100, function() {
            $("#bodyFader").remove();
            dragcounter = 0;
            faded = false;
        });
    }

    //this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
    //it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
    needPostsOlderThan = new Date().getTime();

    //scripts for rearranging the embeds within the text editor

    //these event listener functions are initially attached to the embeds' movement handles,when they're created, above

    function mousedownOnHandle(mouseDownEvent) {
        mouseDownEvent.preventDefault();
        var selectedImage = $(this).parent().parent();

        //turms selectedImage into a spacer element. floatyImageCont is going to contain the image now instead.
        var floatyImageCont = prepareImageForMoving(selectedImage);

        floatyImageCont[0].pointerOffset = mouseDownEvent.originalEvent.clientY - getTop(floatyImageCont);

        prevPointerY = mouseDownEvent.originalEvent.clientY;

        $(document).mousemove(function(e) {
            e.preventDefault();
            moveimagecont(e.originalEvent.clientY, floatyImageCont, selectedImage);
            return false;
        });

        $(document).on('mouseup', function(e) {
            endMovement();
            $(document).off('mousemove');
            $(document).off('mouseup');
        });
    }

    var touchinprogress = false;

    function touchStartOnHandle(e) {

        if (e.cancelable) {
            e.preventDefault();
        }

        if (touchinprogress) {
            return; //don't want to try to move two images at once, everything would probably need to be rewritten for that
        }
        touchinprogress = true;

        var selectedImage = $(this).parent().parent();

        var floatyImageCont = prepareImageForMoving(selectedImage);

        floatyImageCont[0].pointerOffset = e.changedTouches[0].clientY - getTop(floatyImageCont);

        prevPointerY = e.changedTouches[0].clientY;

        //function to be passed to the touchmove handler and then later removed from it
        function touchmoveevent(event) {
            //this should always be true, if it's not preventDefault raises an error instead of preventing page scrolling and we have Problems
            if (event.cancelable) {
                event.preventDefault();
            }
            moveimagecont(event.changedTouches[0].clientY, floatyImageCont, selectedImage);
        }

        //for some reason jQuery Did Not Want to work with these touch events. Possibly they would like us to be using jQuery Mobile. But, this is pretty simple, we don't need it.
        this.addEventListener("touchmove", touchmoveevent, { passive: false });

        this.addEventListener('touchend', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            endMovement();
        });

        this.addEventListener('touchcancel', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            endMovement();
        });
    }

    //gets the position to the element's top relative to the top of the screen, like how the css top property works with position:fixed
    function getTop(e) {
        return e.offset().top - $(window).scrollTop();
    }

    //called as soon as movement is initiated:
    //this functions creates and returns a new, floaty version of the element you pass in and turns the original into an empty "spacer"
    function prepareImageForMoving(selectedImage) {
        var spacer = selectedImage;

        var imagecont = spacer.clone(false);
        imagecont.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });
        imagecont.find('.image-move').on('mousedown', mousedownOnHandle);
        imagecont.find('.image-clear').click(clearEmbed);

        spacer.addClass("imagecontspacer");
        spacer.attr('id', '');

        imagecont.css("width", spacer.outerWidth(true) + "px");
        imagecont.css("left", spacer.offset().left + "px");
        imagecont.css("top", getTop(spacer) + "px");

        spacer.closest('.ql-container').append(imagecont);

        //these can be put in the css file under .onthemove if that's preferred. I guess I would rather have them here
        imagecont.css("position", "fixed");
        imagecont.css("z-index", 2147483647); // over 9000
        imagecont.css("background-color", "white");

        imagecont.addClass("onthemove");

        spacer.css("border", "dashed")
        spacer.empty();

        imagecont[0].scrollPrompterId = setInterval(function() { scrollPrompter(imagecont, spacer) }, 50);

        lastWindowPos = window.scrollY;
        $(window).on('scroll', function(e) {
            if (window.scrollY > lastWindowPos) {
                moveimagecont(prevPointerY, imagecont, spacer, "down")
            } else if (window.scrollY < lastWindowPos) {
                moveimagecont(prevPointerY, imagecont, spacer, "up")
            }
            lastWindowPos = window.scrollY;
        })

        return imagecont;
    }

    //assumes a window that's at least 300px tall
    function scrollPrompter(imagecont, spacer) {
        var t = getTop(imagecont);
        if (t < 100) {
            $(window).scrollTop($(window).scrollTop() - 10);
        } else if (t > window.innerHeight - 200) {
            $(window).scrollTop($(window).scrollTop() + 10);
        }
    }

    //this function is called when the user moves either their mouse or finger to reposition the embed or the screen scrolls in a scrollDirection
    function moveimagecont(pointerY, imagecont, spacer, scrollDirection) {
        var deltaY = pointerY - prevPointerY;
        prevPointerY = pointerY;
        //move the floaty element:
        var imageconttop = getTop(imagecont);
        var spacertop = getTop(spacer);
        var imageconth = imagecont.outerHeight(true);
        //new y pos is the old y pos + the mouse's delta-y unless that's less than the parent's top bound or more than the parent's bottom bound - the height of the element
        var newYPos = Math.min(Math.max(pointerY - imagecont[0].pointerOffset, getTop(spacer.parent())), getTop(spacer.parent()) + (spacer.parent().outerHeight(true) - spacer.outerHeight(true))); //beauty
        imagecont.css("top", newYPos + "px");

        //move the spacer (maybe):

        if (scrollDirection == "down" || deltaY > 0) { //moving down
            var elementBelow = spacer.next();
            while (elementBelow.length && elementBelow.next().length && (imageconttop + imageconth) > (getTop(elementBelow) + elementBelow.outerHeight(true))) {
                elementBelow = elementBelow.next();
            }
            if (elementBelow.length) {
                var ebt = getTop(elementBelow);
                var line = Math.max(ebt + (0.5 * elementBelow.outerHeight(true)), ebt + elementBelow.outerHeight(true) - 70);
                if ((imageconttop + imageconth) > line) {
                    spacer.insertAfter(elementBelow);
                }
            }
        } else if (scrollDirection == "up" || deltaY < 0) { //moving up
            var elementAbove = spacer.prev();
            while (elementAbove.length && elementAbove.prev().length && imageconttop < getTop(elementAbove)) {
                elementAbove = elementAbove.prev();
            }
            if (elementAbove.length) {
                var line = Math.min(getTop(elementAbove) + (0.5 * elementAbove.outerHeight(true)), getTop(elementAbove) + 70);
                if (imageconttop < line) {
                    spacer.insertBefore(elementAbove);
                }
            }
        }
    }

    //this function is called when the user lifts their finger from their screen or mouse button and the image can find its spot. it's all called to just
    //generally cancel drag and dropping when an alert has to be displayed about an upload, just in case drag and dropping is going on
    function endMovement() {
        var imagecont = $('.onthemove');
        if (imagecont.length) {
            clearInterval(imagecont[0].scrollPrompterId);
            $(window).off('scroll');
            $('.imagecontspacer').after($('.onthemove'));
            imagecont.css("position", "").css("border", "").css('width', '').css('left', '').css('top', '').css('height', '').css("z-index", 10); //seems like a good number
            imagecont.removeClass("onthemove");
            var spacer = $('.imagecontspacer');
            if (!spacer.next().length && !(spacer.prev().length && spacer.prev().text().trim() == "")) {
                spacer.after("<p></p>")
            }
            spacer.remove();
        }
    }
</script>