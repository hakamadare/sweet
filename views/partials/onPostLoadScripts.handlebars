<script type="text/javascript">
function attachQuill(element, placeholder) {
    var quill = new Quill(element, {
        modules: {
            toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
            keyboard: {
                bindings: {
                    //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                    blqtBksp: {
                        key: 'backspace',
                        collapsed: true,
                        format: ['blockquote'],
                        offset: 0,
                        handler: function(range, context) {
                            this.quill.format('blockquote', false);
                        }
                    }
                }
            }
        },
        placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
        theme: 'bubble'
    });
    //remove pasted images
    quill.clipboard.addMatcher("img", function(node, delta) {
        return { ops: [] };
    });
    //remove pasted formatting that we don't support
    quill.clipboard.addMatcher("*", function(node, delta) {
        for (var i = 0; i < delta.ops.length; i++) {
            for (const key in delta.ops[i].attributes) {
                if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                    delete delta.ops[i].attributes[key];
                }
            }
        }
        return delta;
    })
    //save the most recent cursor position when the editor loses focus
    quill.on('selection-change', function(range, oldRange, source) {
        if (!range) {
            element.lastCursorPos = oldRange.index;
        }
    })
    element.insertEmojiAtCursor = function(emojiString) {
        var range = undefined;
        if (range = quill.getSelection()) { //if editor has focus
            if (range.length > 0) { //if there is some text selected
                quill.deleteText(range.index, range.length);
            }
            quill.insertText(range.index, emojiString)
        } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
            quill.insertText(element.lastCursorPos, emojiString)
        } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
            quill.insertText(0, emojiString)
            quill.focus()
            quill.setSelection(emojiString.length, 0)
        }
    }
    element.hasContent = function() {
        return $(element).text().trim().length !== 0;
    }
    element.specialAddImages = function(imgarray) {
        var fileInput = $(this).closest('.new-comment-form, .contentForm').find(".file-input");
        fileInput[0].pastedFiles = imgarray;
        //we attach that function to the file input object events when necessary. can't do them all at once 'cause they're not loaded all at once
        if (!fileInput[0].changeEventAttached) {
            fileInput.change(fileselected);
            fileInput[0].changeEventAttached = true;
        }
        fileInput.change();
    }
    //listen for and use pasted image data
    element.onpaste = function(e) {
        // event.originalEvent.clipboard for newer chrome versions
        var items = (event.clipboardData || event.originalEvent.clipboardData).items;
        // find pasted image among pasted items
        var imgarray = [];
        for (var i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") === 0) {
                imgarray.push(items[i].getAsFile());
            }
        }
        this.specialAddImages(imgarray)
    }
    //listen for and use dragged-and-dropped images
    element.ondrop = function(ev) {
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            var imgarray = [];
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                    imgarray.push(ev.dataTransfer.items[i].getAsFile());
                }
            }
            this.specialAddImages(imgarray);
        } else {
            this.specialAddImages(ev.dataTransfer.files); //the code in fileselected() will have to make sure they at least have the apparent mime type of supported images
        }
    }
}

//this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
//it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
needPostsOlderThan = new Date().getTime();

$(function() {
    
{{#if loggedIn}}
    // TRIBUTE-RELATED FUNCTIONALITY (@-MENTIONS)
    // Init tribute
    $.post('/api/user/followers', function (data) {
        followers = JSON.parse(data).followers;
        tribute = new Tribute({
            values: followers,
            menuItemTemplate: function (item) {
                return '<img class="tribute-image" src="/images/' + item.original.image + '">' + item.string;
            }
        })
        tribute.attach($(".ql-editor")); //attach to new post form and comment fields if there are any that aren't handled when their posts are appended (look a few lines down for that)
    });

{{/if}}
    // Attach scripts to newly loaded posts
    $('#postsContainer').on('append.infiniteScroll', function (event, response, path, items) {
        var newlyLoadedStuff = $(items);

        if(this.fadedOut){
            $(this).fadeIn(250);
        }

        needPostsOlderThan = newlyLoadedStuff.last().find("#oldesttimestamp").html(); //the new oldest-post-loaded timestamp is provided by the server in this element

        if (newlyLoadedStuff.find('.post-images').length > 0) {
            var imagesLoaded = newlyLoadedStuff.find('.post-single-image').length;
            console.log("images loaded: " + imagesLoaded);
            var imagesLightboxed = 0;

            var $images = newlyLoadedStuff.find('.post-images a');
            var $imagesGrouped = $images.filter('[data-group]');
            var $imagesAlone = $images.not($imagesGrouped);
            var params = {
                // your params
            };

            // Handle standalone images
            $imagesAlone.each(function (index, element) {
                $(element).simpleLightbox(params);
                imagesLightboxed++;
            });

            // Handle grouped images
            if ($imagesGrouped.length > 0) {
                // Select all groups
                var groupNames = $imagesGrouped.map(function () {
                    return $(this).data('group');
                }).get();
                groupNames = $.unique(groupNames);

                // Apply on each group
                $.each(groupNames, function (key, value) {
                    var filteredGroup = $imagesGrouped.filter(function () { //could this be .find instead of .filter so that it just finds the one instance and stops
                        return $(this).data('group') == value;
                    })
                    filteredGroup.simpleLightbox(params);
                    imagesLightboxed += filteredGroup.length;
                });
                console.log("images lightboxed: " + imagesLightboxed)
                if (imagesLightboxed != imagesLoaded) {
                    console.log("not all images lightboxed!!!!!!");
                }
                //$.post("/admin/clientsideerrors",{errortext: "not all images lightboxed: "+imagesLoaded+" loaded, "+imagesLightboxed+" lightboxed"})
            }
        }
        {{#if loggedIn}}
        var commentForms = newlyLoadedStuff.find('.editable-text');
        commentForms.each(function(){
            attachQuill(this,'Reply to this post with a good reply');
        })
        if (typeof tribute !== 'undefined') { // Silently fails to load tribute if API has not yet responded, it will be attached to these comment fields when tribute does load (look up a few lines)
            tribute.attach(newlyLoadedStuff.find(".ql-editor"));
        }
        {{/if}}
    });
});
</script>
