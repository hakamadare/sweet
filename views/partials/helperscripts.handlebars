<script id="new-comment-form-template" type="text/x-handlebars-template">
<div class="new-comment-form" data-comment-type="\{{comment_type}}" data-post-id="\{{post_id}}" data-comment-id="\{{comment_id}}">
  <div class="form-row">
    <div class="editable-post-content editable-text" id="postContent">
      <p><br></p>
    </div>
  </div>
  <div class="form-row my-2 card p-1 replyEmojiWindow" style="display:none">
      <button type="button" class="add-emoji">🍬</button>
      <button type="button" class="add-emoji">🍭</button>
      <button type="button" class="add-emoji">🍡</button>
      <button type="button" class="add-emoji">🍩</button>
      <button type="button" class="add-emoji">🍪</button>
      <button type="button" class="add-emoji">🍫</button>
      <button type="button" class="add-emoji">🎂</button>
      <button type="button" class="add-emoji">🍯</button>
      <button type="button" class="add-emoji">🍎</button>
      <button type="button" class="add-emoji">🍑</button>
      <button type="button" class="add-emoji">🍌</button>
      <button type="button" class="add-emoji">🍓</button>
      <button type="button" class="add-emoji">🍇</button>
      <button type="button" class="add-emoji">🍉</button>
      <button type="button" class="add-emoji">🐝</button>
      <button type="button" class="add-emoji">😊</button>
      <button type="button" class="add-emoji">🙃</button>
      <button type="button" class="add-emoji">😍</button>
      <button type="button" class="add-emoji">😂</button>
      <button type="button" class="add-emoji">😭</button>
      <button type="button" class="add-emoji">😬</button>
      <button type="button" class="add-emoji">😆</button>
      <button type="button" class="add-emoji">😩</button>
      <button type="button" class="add-emoji">😱</button>
      <button type="button" class="add-emoji">😒</button>
      <button type="button" class="add-emoji">🖖</button>
      <button type="button" class="add-emoji">🙌</button>
      <button type="button" class="add-emoji">👏</button>
      <button type="button" class="add-emoji">👌</button>
      <button type="button" class="add-emoji">💪</button>
      <button type="button" class="add-emoji">🤦</button>
      <button type="button" class="add-emoji">🌱</button>
      <button type="button" class="add-emoji">🌞</button>
      <button type="button" class="add-emoji">🌝</button>
      <button type="button" class="add-emoji">❤️</button>
      <button type="button" class="add-emoji">💕</button>
      <button type="button" class="add-emoji">💖</button>
      <button type="button" class="add-emoji">🔥</button>
      <button type="button" class="add-emoji">🎉</button>
      <button type="button" class="add-emoji">💯</button>
      <button type="button" class="add-emoji">🏳️‍🌈</button>
  </div>
  <div id="image-preview-holder" class="form-row post-controls image-preview-holder">
    <input type="file" class="file-input" accept="image/gif, image/jpeg, image/png" aria-label="Choose image" name="postImage" multiple>
  </div>
  <div id="replyControlsRow" class="form-row mt-2 post-controls">
    <div class="leftSideControls">
      <button type="button" class="btn btn-primary btn-fade" id="postImageButton"><i class="fas fa-image"></i></button><button type="button" class="btn btn-primary btn-fade replyEmojiWindowButton"><i class="far fa-smile"></i></button>
    </div>
    <div class="rightSideControls">
      <button type="submit" class="btn btn-primary btn-fade create-comment">Reply <i class="fas fa-chevron-right"></i></button>
    </div>
  </div>
</div>
</script>

<script type="text/javascript">

function attachQuill(element,placeholder){
    var quill = new Quill(element, {
        modules: {
            toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
            keyboard:{
                bindings:{
                    //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                    blqtBksp:{
                        key: 'backspace', collapsed: true, format: ['blockquote'], offset: 0,
                        handler: function(range, context) {
                            this.quill.format('blockquote', false);
                        }
                    }
                }
            }
        },
        placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
        theme: 'bubble'
    });
    //remove pasted images
    quill.clipboard.addMatcher("img", function(node, delta) {
        return {ops:[]};
    });
    //remove pasted formatting that we don't support
    quill.clipboard.addMatcher("*",function(node, delta){
        for(var i=0;i<delta.ops.length;i++){
            for (const key in delta.ops[i].attributes){
                if(key!="bold" && key!="italic" && key!="link" && key!="blockquote" && key!="list"){
                    delete delta.ops[i].attributes[key];
                }
            }
        }
        return delta;
    })
    //save the most recent cursor position when the editor loses focus
    quill.on('selection-change', function(range,oldRange,source){
        if(!range){
            element.lastCursorPos = oldRange.index;
        }
    })
    element.insertEmojiAtCursor = function(emojiString){
        var range = undefined;
        if(range = quill.getSelection()){ //if editor has focus
            if(range.length > 0){ //if there is some text selected
                quill.deleteText(range.index,range.length);
            }
            quill.insertText(range.index,emojiString)
        }else if(element.lastCursorPos){ //if editor has had focus and thus an active cursor position previously
            quill.insertText(element.lastCursorPos,emojiString)
        }else{ //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
            quill.insertText(0,emojiString)
            quill.focus()
            quill.setSelection(emojiString.length,0)
        }
    }
    element.hasContent = function(){
        return $(element).text().trim().length !== 0;
    }
}

//this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
//it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
lastpostloadedtime = new Date().getTime();

$(function() {
    //this is here bc this is the first of our scripts to be linked in in the layout, and this should be the first thing the browser does
    window.onerror = function(errorMessage, source, lineno, colno, error){
        if(source == "Error: Not Found"){
            return; //this is a routine error coming from scrolling to the bottom of an infinite scroll feed, it's not a problem, unless something weird happens later
        }
        var errorstring = "error: "+errorMessage+"\noriginating from script: "+source+" on line "+lineno+" and column "+colno;
        if(error && error.stack){
            errorstring+="\nfull stack trace: \n" + error.stack;
        }
        if(error && error.message){
            errorstring+="\nerror object message: "+error.message;
        }
        if(errorMessage && errorMessage.message){ //it looks like some browsers just use an error object as the first paramater
            errorstring+="\nother message: "+errorMessage.message;
        }
        if(errorMessage && errorMessage.stack){
            errorstring+="\npossibly second stack trace: \n"+errorMessage.stack;
        }
        if (typeof errorMessage == "object") {
            errorstring += "\nnamespace: "+errorMessage.namespace;
        }
        if(window.navigator && window.navigator.userAgent){
            errorstring+="\nbrowser user agent header: "+window.navigator.userAgent;
        }
        $.post("/admin/reporterror", {errorstring: errorstring});
    }

{{#if loggedIn}}
    // TRIBUTE-RELATED FUNCTIONALITY (@-MENTIONS)
    // Init tribute
    $.post('/api/user/followers', function (data) {
        followers = JSON.parse(data).followers;
        tribute = new Tribute({
            values: followers,
            menuItemTemplate: function (item) {
                return '<img class="tribute-image" src="/images/' + item.original.image + '">' + item.string;
            }
        })
        tribute.attach($(".ql-editor")); //attach to new post form and comment fields if there are any that aren't handled when their posts are appended (look a few lines down for that)
    });

{{/if}}
    // Attach scripts to newly loaded posts
    $('#postsContainer').on('append.infiniteScroll', function (event, response, path, items) {
        var newlyLoadedStuff = $(items);

        lastpostloadedtime = newlyLoadedStuff.last().find("#lastposttimestamp").html(); //the new oldest-post-loaded timestamp is provided by the server in this element
        console.log(lastpostloadedtime)
        console.log(newlyLoadedStuff.last())

        if (newlyLoadedStuff.find('.post-images').length > 0) {
            var imagesLoaded = newlyLoadedStuff.find('.post-single-image').length;
            console.log("images loaded: " + imagesLoaded);
            var imagesLightboxed = 0;

            var $images = newlyLoadedStuff.find('.post-images a');
            var $imagesGrouped = $images.filter('[data-group]');
            var $imagesAlone = $images.not($imagesGrouped);
            var params = {
                // your params
            };

            // Handle standalone images
            $imagesAlone.each(function (index, element) {
                $(element).simpleLightbox(params);
                imagesLightboxed++;
            });

            // Handle grouped images
            if ($imagesGrouped.length > 0) {
                // Select all groups
                var groupNames = $imagesGrouped.map(function () {
                    return $(this).data('group');
                }).get();
                groupNames = $.unique(groupNames);

                // Apply on each group
                $.each(groupNames, function (key, value) {
                    var filteredGroup = $imagesGrouped.filter(function () { //could this be .find instead of .filter so that it just finds the one instance and stops
                        return $(this).data('group') == value;
                    })
                    filteredGroup.simpleLightbox(params);
                    imagesLightboxed += filteredGroup.length;
                });
                console.log("images lightboxed: " + imagesLightboxed)
                if (imagesLightboxed != imagesLoaded) {
                    console.log("not all images lightboxed!!!!!!");
                }
                //$.post("/admin/clientsideerrors",{errortext: "not all images lightboxed: "+imagesLoaded+" loaded, "+imagesLightboxed+" lightboxed"})
            }
        }
        {{#if loggedIn}}
        var commentForms = newlyLoadedStuff.find('.editable-text');
        commentForms.each(function(){
            attachQuill(this,'Reply to this post with a good reply');
        })
        if (typeof tribute !== 'undefined') { // Silently fails to load tribute if API has not yet responded, it will be attached to these comment fields when tribute does load (look up a few lines)
            tribute.attach(newlyLoadedStuff.find(".ql-editor"));
        }
        {{/if}}
    });

    {{#if loggedIn}}

    var editor = undefined;
    if(editor = document.getElementById('editor')){
        attachQuill(editor)
    }

    {{/if}}
});
</script>
